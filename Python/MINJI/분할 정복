1단계-No.2630-색종이 만들기
import sys
n=int(sys.stdin.readline())
 
color_paper=[list(map(int,sys.stdin.readline().split())) for _ in range(n)]#x행 y열
 
white=0#0이면 흰생
blue=0#1이면 파란색
 
def cut(x,y,n):
    global blue,white
    check=color_paper[x][y]
    for i in range(x,x+n):
        for j in range(y,y+n):
            if check!=color_paper[i][j]:#하나라도 같은색이 아니라면
                #4등분
                cut(x,y,n//2)#1사분면
                cut(x,y+n//2,n//2)#2사분면
                cut(x+n//2,y,n//2)#3사분면
                cut(x+n//2,y+n//2,n//2)#4사분면
                return
 
 
    if check==0:#모두 흰색일때
        white+=1
        return
    else:   #모두 파란색일때
        blue+=1
        return
 
 
cut(0,0,n)
print(white)
print(blue)

2단계-No.1992-쿼드트리
N = int(input())

image = [list(map(int, input())) for _ in range(N)]

def quadtree(x, y, n):
    # n = 1, 하나의 픽셀만 볼 경우,
    if(n == 1):
        return str(image[x][y])
    
    result = []
    for i in range(x, x + n):
        for j in range(y, y + n):
            # 색이 다르면, 다시 분할하자.
            if(image[i][j] != image[x][y]):
                # append와 extend의 차이는
                # extend는 list, tuple, dict 등의 iterable object를
                # python list의 끝에 append 해주는 것.
                result.append('(')
                result.extend(quadtree(x, y, n//2))
                result.extend(quadtree(x, y + n//2, n//2))
                result.extend(quadtree(x + n//2, y, n//2))
                result.extend(quadtree(x + n//2, y + n//2, n//2))
                result.append(')')
                
                return result
            
    return str(image[x][y])
    
print(''.join(quadtree(0, 0, N)))

3단계-No.1780-종이의 개수
N = int(input())

paper = [list(map(int, input().split())) for _ in range(N)]

neg = 0
neut = 0
pos = 0

def clip_paper(x, y, n):
    global neg, neut, pos
    
    num_check = paper[x][y]
    for i in range(x, x + n):
        for j in range(y, y + n):
            if(paper[i][j] != num_check):
                for k in range(3):
                    for l in range(3):
                        clip_paper(x + k * n//3, y + l * n//3, n//3)
                return
            
    if(num_check == -1):
        neg += 1
    elif(num_check == 0):
        neut += 1
    else:
        pos += 1
        
clip_paper(0, 0, N)
print(f'{neg}\n{neut}\n{pos}')

4단계-No.1629-곱셈
import sys

A, B, C = map(int, sys.stdin.readline().split())

memos = {1:A%C}

def mul(A, B): 
    return ((A%C) * (B%C))%C
def process(k): 
    if (k in memos.keys()):
        return memos[k]
    q = int(k / 2)
    data = mul(process(q), process(k-q))
    memos[k] = data
    return data
print(process(B))

5단계-No.11401-이항 계수-3
설명 - https://jda2002.tistory.com/entry/BOJ-%EB%B0%B1%EC%A4%80-11401%EB%B2%88-%EC%9D%B4%ED%95%AD-%EA%B3%84%EC%88%98-3
n, k = map(int,input().split())
p = 1000000007
def mul(a,b):
    if b == 0:
        return 1
    elif b == 1:
        return a
    elif b % 2 > 0:
        return mul(a, b-1) * a
    else:
        d = mul(a, b // 2)
        d %= p
        return d ** 2 % p
    
A = 1
B = 1
for i in range(1,n+1):
    A *= i
    A %= p
for i in range(1, k+1):
    B *= i
    B %= p
for i in range(1, n-k+1):
    B *= i
    B %= p
    
B = mul(B,(p-2) % p)
print((A * B) % p)
