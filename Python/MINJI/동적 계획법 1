1단계-No.2748-피보나치 수-2
num = int(input())

arr = [0 for _ in range(num + 1)]

arr[1] = 1

for i in range(2, num + 1):
    arr[i] = arr[i - 1] + arr[i - 2]

print(arr[-1])

2단계-No.1003-피보나치 함수
def fib(num):
    countZero = [1, 0]
    countOne = [0, 1]
    
    if num <= 1:
        return
    
    for i in range(2, num + 1):
        countZero.append(countZero[i - 1] + countZero[i - 2])
        countOne.append(countOne[i - 1] + countOne[i - 2])
    
    return countZero, countOne

turn = int(input()) # 테스트 케이스의 개수

countZero, countOne = fib(40) # 수열 만들어주기

for _ in range(turn):
    num = int(input())
    print("%d %d" %(countZero[num], countOne[num]))

3단계-No.1904-01타일
num = int(input())

arr = [0 for _ in range(1000001)]
arr[1] = 1
arr[2] = 2

for i in range(3, num + 1):
    arr[i] = ((arr[i - 2] % 15746) + (arr[i - 1] % 15746)) % 15746

print(arr[num])

4단계-No.9461-파도반 수열
turn = int(input())

arr = [0 for _ in range(101)]

arr[0] = 1
arr[1] = 1
arr[2] = 1

for i in range(3, 101):
    arr[i] = arr[i - 2] + arr[i - 3]

for i in range(turn):
    num = int(input())
    print(arr[num - 1])

5단계-No.1149-RGB거리
turn = int(input())

arr = []

for i in range(turn):
    arr.append(list(map(int, input().split())))

for i in range(1, len(arr)):
    arr[i][0] = min(arr[i - 1][1], arr[i - 1][2]) + arr[i][0]
    arr[i][1] = min(arr[i - 1][0], arr[i - 1][2]) + arr[i][1]
    arr[i][2] = min(arr[i - 1][0], arr[i - 1][1]) + arr[i][2]

print(min(arr[turn - 1][0], arr[turn - 1][1], arr[turn - 1][2]))

6단계-No.1932-정수 삼각형
turn = int(input())
triArr = [list(map(int, input().split())) for _ in range(turn)]

for i in range(turn - 1):
    for j in range(len(triArr[i + 1])):
        # 첫 번째와 끝 부분은 그냥 더해준다.
        if(j == 0):
            triArr[i + 1][j] = triArr[i][j] + triArr[i + 1][j]
        elif(j == len(triArr[i + 1]) - 1):
            triArr[i + 1][-1] = triArr[i][-1] + triArr[i + 1][-1]
        else:
            triArr[i + 1][j] = max(triArr[i][j - 1] + triArr[i + 1][j], triArr[i][j] + triArr[i + 1][j])

print(max(triArr[-1]))

7단계-No.2579-계단 오르기
n = int(input())
s = [0 for i in range(301)] # 점수 리스트
dp = [0 for i in range(301)] # 점수의 합 저장

for i in range(n):
    s[i] = int(input())

dp[0] = s[0] # 첫 번째 점수
dp[1] = s[0] + s[1] # 첫 번째 점수와 두 번째 점수를 합한 값
dp[2] = max(s[1] + s[2], s[0] + s[2])
for i in range(3, n):
    dp[i] = max(dp[i - 3] + s[i - 1] + s[i], dp[i - 2] + s[i])
    # 마지막 계단의 전 계단을 밟은 경우와
    # 마지막 계단의 전 계단을 밟지 않은 경우
print(dp[n - 1])

8단계-No.1463-1로 만들기
turn = int(input())

result = [0 for _ in range(turn + 1)]

for i in range(1, turn + 1):
    if i == 1:
        result[i] = 0
        continue
    result[i] = result[i - 1] + 1
    if i % 3 == 0 and result[i // 3] + 1 < result[i]:
        result[i] = result[i // 3] + 1
    if i % 2 == 0 and result[i // 2] + 1 < result[i]:
        result[i] = result[i // 2] + 1

print(result[turn])

9단계-No.10844-쉬운 계단 수
n = int(input())
dp = [[0 for i in range(10)] for j in range(101)]
for i in range(1, 10):
    dp[1][i] = 1
for i in range(2, n + 1):
    for j in range(10):
        if j == 0:
            dp[i][j] = dp[i - 1][1]
        elif j == 9:
            dp[i][j] = dp[i - 1][8]
        else:
            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
print(sum(dp[n]) % 1000000000)

10단계-No.2156-포도주 시식
turn = int(input())
wineArr = [int(input()) for i in range(turn)]

dp = [0]
dp.append(wineArr[0])
if turn > 1:
    dp.append(wineArr[0] + wineArr[1])

# 이번 포도주 + 이전 포도주 X
# 이번 포도주 + 이전 포도주 O
# 이번 포도주 X

for i in range(3, turn + 1):
    first = wineArr[i - 1] + dp[i - 2]
    second = wineArr[i - 1] + wineArr[i - 2] + dp[i - 3]
    third = dp[i - 1]
    maxRes = max(first, second, third)
    
    dp.append(maxRes)

print(dp[turn])
